#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"
#include "images/start.h"
#include "images/square_snake.h"
#include "images/over.h"
#include "images/win.h"
#include "images/timeup.h"
//#include "images/square_candy.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
  TIMEUP,
};
//unsigned int timer = 0;

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;
  

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;
  int grow = rand() % 136 + 15;
  int gcol = rand() % 136 + 15;
  int obrow = rand() % 136 + 15;
  int obcol = rand() % 136 + 15;
  int ob1row = rand() % 136 + 15;
  int ob1col = rand() % 136 + 15;

  struct position s = {0, (HEIGHT - SQUARE_SNAKE_HEIGHT)};
  struct position gp = {grow , gcol};
  struct position ob = {obrow , obcol};
  struct position ob1 = {ob1row , ob1col};
  // struct position center = {120, 80};
  // int radius = 50;

  int point = 0;
  int time = 0;
  char loseStr[500];
  char arr[100];

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    waitForVBlank();
    // NOTE: Call waitForVBlank() before you draw

    switch (state) {
      case START:
        //start screen
        //drawImageDMA(0, 0, 240, 160, start); 
        drawFullScreenImageDMA(start);
        point = 0;

        // int snake_x = 0;
        // int snake_y = 0;
        // drawImageDMA(snake_x, snake_y, SQUARE_SNAKE_WIDTH,SQUARE_SNAKE_HEIGHT, square_snake);
        // snake_x++;
        // if (snake_x > WIDTH) {
        //   snake_x = 0;
        //   snake_y = rand() % HEIGHT;
        // }

        snprintf(arr, 100, "Press ENTER to begin");
        drawString(60, 60, arr, BLACK);
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          fillScreenDMA(WHITE);
          vBlankCounter = 0;
          state = PLAY;
        }

        break;
      case PLAY:
        // play screen
        drawRectDMA(0, 0, 70, 10, WHITE);
        snprintf(arr, 100, "Score:%d", point);
        time = vBlankCounter / 60;
        drawString(0, 0, arr, BLACK);

        drawString(0, 100, "Time:", BLACK);
        int elapsedTime = (vBlankCounter - 0) / 60;
        int hours = elapsedTime / 3600;
        int minutes = (elapsedTime % 3600) / 60;
        int seconds = elapsedTime % 60;
        char hoursStr[3], minutesStr[3], secondsStr[3];
        snprintf(hoursStr, 6, "%02d", hours);
        snprintf(minutesStr, 5, "%02d", minutes);
        snprintf(secondsStr, 5, "%02d", seconds);
        char timerStr[9];
        snprintf(timerStr, 9, "%s:%s:%s", hoursStr, minutesStr, secondsStr);
        drawRectDMA(0, 140, 60, 8, WHITE);
        drawString(0, 140, timerStr, BLACK);

        // snprintf(arr, 100, "%d", elapsedTime);
        // drawString(0, 140, arr, BLACK);
        //drawRectDMA(0, 140, 70, 10, WHITE);

        drawImageDMA(s.col, s.row, SQUARE_SNAKE_WIDTH, SQUARE_SNAKE_HEIGHT, square_snake);
        drawRectDMA(gp.col, gp.row, RECT_WIDTH, RECT_HEIGHT, BLUE);
        drawRectDMA(ob.col, ob.row, RECT_WIDTH, RECT_HEIGHT, RED);
        drawRectDMA(ob1.col, ob1.row, RECT_WIDTH, RECT_HEIGHT, RED);
        if (gp.row >= s.row && gp.row < s.row + SQUARE_SNAKE_HEIGHT && gp.col >= s.col && gp.col < s.col + SQUARE_SNAKE_WIDTH) {
            // remove rect and generate new random position
            drawRectDMA(gp.col, gp.row, RECT_WIDTH, RECT_HEIGHT, WHITE);
            drawRectDMA(ob.col, ob.row, RECT_WIDTH, RECT_HEIGHT, WHITE);
            drawRectDMA(ob1.col, ob1.row, RECT_WIDTH, RECT_HEIGHT, WHITE);
            gp.row = rand() % 136 + 15;
            gp.col = rand() % 136 + 15;
            ob.row = rand() % 136 + 15;
            ob.col = rand() % 136 + 15;
            ob1.row = rand() % 136 + 15;
            ob1.col = rand() % 136 + 15;
            point++;
          }
        if (ob.row >= s.row && ob.row < s.row + SQUARE_SNAKE_HEIGHT && ob.col >= s.col && ob.col < s.col + SQUARE_SNAKE_WIDTH){
          drawRectDMA(gp.col, gp.row, RECT_WIDTH, RECT_HEIGHT, WHITE);
          drawRectDMA(ob.col, ob.row, RECT_WIDTH, RECT_HEIGHT, WHITE);
          drawRectDMA(ob1.col, ob1.row, RECT_WIDTH, RECT_HEIGHT, WHITE);
          gp.row = rand() % 136 + 15;
          gp.col = rand() % 136 + 15;
          ob.row = rand() % 136 + 15;
          ob.col = rand() % 136 + 15;
          ob1.row = rand() % 136 + 15;
          ob1.col = rand() % 136 + 15;
          point--;
        }

        if (ob1.row >= s.row && ob1.row < s.row + SQUARE_SNAKE_HEIGHT && ob1.col >= s.col && ob1.col < s.col + SQUARE_SNAKE_WIDTH){
          drawRectDMA(gp.col, gp.row, RECT_WIDTH, RECT_HEIGHT, WHITE);
          drawRectDMA(ob.col, ob.row, RECT_WIDTH, RECT_HEIGHT, WHITE);
          drawRectDMA(ob1.col, ob1.row, RECT_WIDTH, RECT_HEIGHT, WHITE);
          gp.row = rand() % 136 + 15;
          gp.col = rand() % 136 + 15;
          ob.row = rand() % 136 + 15;
          ob.col = rand() % 136 + 15;
          ob1.row = rand() % 136 + 15;
          ob1.col = rand() % 136 + 15;
          point--;
        }

        // float angle = vBlankCounter * 0.05f; // convert to radians
        // int x = (int)(center.col + radius * cos(angle));
        // int y = (int)(center.row + radius * sin(angle));
        // drawRectDMA(x, y, RECT_WIDTH, RECT_HEIGHT, RED);
        

        if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
          if (s.row < (240 - SQUARE_SNAKE_WIDTH)){
            s.row++;
          } else {
            state = LOSE;
          }
        }
        if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
          if (s.row > 0) {
            s.row--;
          } else {
            state = LOSE;
          }
        }
        if (KEY_DOWN(BUTTON_UP, currentButtons)) {
          if (s.col > 10) {
            s.col--;
          }

          if (s.col<=0){
            state = LOSE;
          }
        }
        if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
          if (s.col < HEIGHT - SQUARE_SNAKE_HEIGHT) {
            s.col++;
          } else {
            state = LOSE;
          }
        }

        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          s.col = HEIGHT - SQUARE_SNAKE_HEIGHT;
          s.row = 0;
          vBlankCounter = 0;
        }

        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          fillScreenDMA(WHITE);
          vBlankCounter = 0;
          point = 0; // reset score to 0
          state = PLAY;
        }

        //drawImageDMA(gp.col, gp.row, SQUARE_CANDY_WIDTH, SQUARE_CANDY_HEIGHT, square_candy);
        // if (s.row == gp.row){
        //   point++;
        //   fillScreenDMA(WHITE);
        //   grow = rand() % (HEIGHT - RECT_HEIGHT);
        //   gcol = rand() % (WIDTH - RECT_WIDTH);
        //   state = PLAY;
        // }
        // while((point < 20) || (time < 60)){
        //   drawRectDMA(gp.row, gp.col, RECT_WIDTH, RECT_HEIGHT, BLUE);
        //   if (s.row == gp.row){
        //     point++;
        //     //drawRectDMA(int row, int col, int width, int height, volatile u16 color)
        //     drawRectDMA(0, 0, WIDTH, HEIGHT, WHITE);
        //   }
        // }
        if (point >= target){
          state = WIN;
        }
        if ((time >= 60) && (point < target)){
          state = TIMEUP;
        }
        // if (time >= 60){
        //   state = WIN;
        // }
        break;
      case WIN:
        drawFullScreenImageDMA(win);
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          s.col = HEIGHT - SQUARE_SNAKE_HEIGHT;
          s.row = 0;
          vBlankCounter = 0;
        }

        snprintf(loseStr, 500, "Your Score: %d", point);
        drawString(10, 20, loseStr, WHITE);

        snprintf(loseStr, 500, "Press DELETE");
        drawString(30, 20, loseStr, WHITE);

        // state = ?
        break;
      case LOSE:

        // state = ?
        drawFullScreenImageDMA(over);
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          s.col = HEIGHT - SQUARE_SNAKE_HEIGHT;
          s.row = 0;
          vBlankCounter = 0;
        }

        snprintf(loseStr, 500, "Press DELETE/BACKSPACE");
        drawString(10, 20, loseStr, WHITE);

        break;
      
      case TIMEUP:
        drawFullScreenImageDMA(timeup);
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          s.col = HEIGHT - SQUARE_SNAKE_HEIGHT;
          s.row = 0;
          vBlankCounter = 0;
        }
        snprintf(loseStr, 500, "Press DELETE");
        drawString(10, 20, loseStr, BLACK);
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}
